"
" .pluginrc
"
" プラグイン毎の設定
"

if !executable('git')
  finish
endif


" vim-plug {{{1
"
if has('vim_starting')
  if !isdirectory(expand('$VIMLOCAL/bundle/vim-plug'))
    echo 'install vim-plug...'
    call system('git clone https://github.com/junegunn/vim-plug.git '.
          \ expand('$VIMLOCAL/bundle/vim-plug/autoload'))
  end
  set runtimepath+=$VIMLOCAL/bundle/vim-plug

  " suppress warning
  if g:is_win
    let $PERL_BADLANG = 0
  endif
endif

call plug#begin(expand('$VIMLOCAL/bundle'))

Plug 'junegunn/vim-plug', {
      \ 'dir': expand('$VIMLOCAL/bundle/vim-plug/autoload') }

if executable('gcc')
  function! BuildVimproc(info)
    if a:info.status == 'installed' || a:info.force
      if g:is_win
        call system('tools\\update-dll-mingw')
      else
        call system('make')
      endif
    endif
  endfunction
  Plug 'Shougo/vimproc.vim', { 'do': function('BuildVimproc') }
elseif has('kaoriya') && has('vim_starting')
  set runtimepath+=$VIM/plugins/vimproc
endif

Plug 'kana/vim-operator-user'

Plug 'kana/vim-operator-replace', {
      \ 'on': '<Plug>(operator-replace)'
      \ }

Plug 'rhysd/vim-operator-surround', {
      \ 'on': [
      \   '<Plug>(operator-surround-append)',
      \   '<Plug>(operator-surround-delete)',
      \   '<Plug>(operator-surround-replace)'
      \ ]}

Plug 'kana/vim-smartinput', { 'on': [], 'insert': 1 }

Plug 'tomtom/tcomment_vim'

Plug 't9md/vim-quickhl', {
      \ 'on': [
      \   '<Plug>(quickhl-manual-this)',
      \   '<Plug>(quickhl-manual-reset)'
      \ ]}

Plug 'nathanaelkane/vim-indent-guides', {
      \ 'on': 'IndentGuidesToggle'
      \ }

Plug 'vim-scripts/ShowMarks7'

Plug 'taku-o/vim-fix-numbering' , {
      \ 'on': 'FixNumbering'
      \ }

Plug 'osyo-manga/vim-over' , {
      \ 'on': 'OverCommandLine'
      \ }

if executable('ctags')
  Plug 'vim-scripts/taglist.vim', {
      \ 'on': 'TlistToggle'
      \ }

  Plug 'alpaca-tc/alpaca_tags', {
      \ 'for': [
      \   'cpp', 'cs', 'java', 'ruby', 'vim'
      \ ]}
endif

Plug 'vim-scripts/a.vim', {
      \ 'for': [ 'c', 'cpp' ]
      \ }

Plug 'vim-jp/cpp-vim', {
      \ 'for': 'cpp'
      \ }

Plug 'plasticboy/vim-markdown', {
      \ 'for': 'mkd'
      \ }

if has('lua')
  Plug 'Shougo/neocomplete.vim', { 'on': [], 'insert': 1 }
endif

Plug 'osyo-manga/vim-marching', { 'for': 'cpp' }

if executable('javac')
  Plug 'vim-scripts/javacomplete', {
        \ 'do': 'javac autoload/Reflection.java',
        \ 'for': []
        \ }
endif

if executable('ruby')
  Plug 'NigoroJr/rsense', { 'for': [] }
endif

Plug 'Shougo/neosnippet.vim', { 'on': [], 'insert': 1 }
" Plug 'Shougo/neosnippet-snippets'

Plug 'Shougo/unite.vim', {
      \ 'on': [
      \   'Unite',
      \   'UniteWithBufferDir',
      \   'UniteWithCursorWord',
      \   'UniteWithInput',
      \ ]}
Plug 'Shougo/unite-outline', { 'on': [] }
Plug 'Shougo/unite-help', { 'on': [] }
Plug 'tsukkee/unite-tag', { 'on': [] }
Plug 'tacroe/unite-mark', { 'on': [] }
Plug 'zhaocai/unite-scriptnames', { 'on': [] }
Plug 'ujihisa/unite-colorscheme', { 'on': [] }
Plug 'Shougo/neoyank.vim', { 'on': [] }

Plug 'Shougo/neomru.vim'

Plug 'Shougo/vimfiler.vim', {
      \ 'on': [
      \   'VimFiler',
      \   'VimFilerDouble',
      \   'VimFilerTab',
      \   'VimFilerBufferDir',
      \   'VimFilerExplorer',
      \ ]}

Plug 'Shougo/vimshell.vim', {
      \ 'on': [
      \   'VimShell',
      \   'VimShellBufferDir',
      \   'VimShellExecute',
      \   'VimShellInteractive',
      \   'VimShellTerminal',
      \   'VimShellPop'
      \ ]}

Plug 'scrooloose/nerdtree', {
      \ 'on': 'NERDTreeToggle'
      \ }

Plug 'thinca/vim-quickrun', {
      \ 'on': [
      \   'QuickRun',
      \   '<Plug>(quickrun)'
      \ ]}

Plug 'osyo-manga/shabadou.vim', { 'on': [] }
Plug 'osyo-manga/vim-watchdogs', {
      \ 'on': [
      \   'WatchdogsRun',
      \   'WatchdogsRunSilent',
      \   'WatchdogsRunSweep',
      \ ]}

Plug 'thinca/vim-ref', {
      \ 'on': [
      \   'Ref',
      \   '<Plug>(ref-keyword)'
      \ ]}

Plug 'tyru/open-browser.vim', {
      \ 'on': [
      \   'OpenBrowser',
      \   'OpenBrowserSearch',
      \   'OpenBrowserSmartSearch',
      \   '<Plug>(openbrowser-open)',
      \   '<Plug>(openbrowser-search)',
      \   '<Plug>(openbrowser-smart-search)',
      \ ]}

Plug 'kannokanno/previm', {
      \ 'on': 'PrevimOpen'
      \ }

Plug 'mattn/webapi-vim', { 'on': [] }
Plug 'mattn/excitetranslate-vim', {
      \ 'on': 'ExciteTranslate'
      \ }

if executable('w3m')
  Plug 'yuratomo/w3m.vim', {
        \ 'on': [
        \   'W3m',
        \   'W3mHistory',
        \   'W3mHistoryClear',
        \   'W3mLocal',
        \   'W3mSplit',
        \   'W3mTab',
        \   'W3mVSplit',
        \ ]}
endif

Plug 'tyru/restart.vim', {
      \ 'on': 'Restart'
      \ }

Plug 'lilydjwg/colorizer', { 'on': [] }

Plug 'itchyny/lightline.vim'

Plug 'deris/vim-loadafterft'

Plug 'vim-jp/vimdoc-ja'

Plug 'vim-scripts/Colour-Sampler-Pack'

" load local plugins
function! s:load_local_plugins(dir)
  for pl in split(glob(a:dir), '\n')
    Plug pl
  endfor
endfunction
call s:load_local_plugins(expand('$VIMLOCAL/bundle_local/*'))

call plug#end()

let s:plug = {
      \   'plugs': get(g:, 'plugs', {}),
      \   'plugs_order': get(g:, 'plugs_order', {})
      \ }

function! s:plug.is_installed(name)
  return has_key(self.plugs, a:name) ? isdirectory(self.plugs[a:name].dir) : 0
endfunction

function! s:plug.is_loaded(name)
  return has_key(self.plugs, a:name) ? &runtimepath =~ self.plugs[a:name].dir : 0
endfunction

" additional on-demand load
"
" insert mode
function! s:plug.load_on_insert()
  for name in self.plugs_order
    if get(self.plugs[name], 'insert', 0)
      call plug#load(name)
    endif
  endfor
endfunction

augroup _plug_load_on_insert
  au!
  au InsertEnter * call s:plug.load_on_insert() | au! _plug_load_on_insert
augroup END

" register configuration function when loaded
function! s:plug.register_hook(name)
  let subname = substitute(a:name, '[-\|.]', '_', 'g')
  let aug = '_plug_'.subname
  let fnc = 's:plug_'.subname.'()'
  exe 'augroup '.aug
  exe ' au!'
  exe ' au User '.a:name.' call '.fnc.' | au! '.aug
  exe 'augroup END'
endfunction

" user command
command! PS PlugStatus
command! PU PlugUpdate | PlugUpgrade


" vim-operator-replace {{{1
"
if s:plug.is_installed('vim-operator-replace')
  " Example
  "   Riw 単語をレジスタの文字で置換え
  "   Ri# #で囲まれた範囲をレジスタの文字で置換え
  map <silent>R <Plug>(operator-replace)
endif


" vim-operator-surround {{{1
"
if s:plug.is_installed('vim-operator-surround')
  " Example
  "   Saiw( 単語を(で囲む
  "   Sda(  単語を囲む(を削除
  "   Sra({ 単語を囲む(を{に変更
  map <silent>Sa <Plug>(operator-surround-append)
  map <silent>Sd <Plug>(operator-surround-delete)
  map <silent>Sr <Plug>(operator-surround-replace)
endif


" vim-smartinput {{{1
"
if s:plug.is_installed('vim-smartinput')
  function! s:plug_vim_smartinput()
    let cr = s:plug.is_installed('neocomplete.vim') ? '<C-y><CR>' : '<CR>'

    " ruby
    for ptn in [
          \ '^\s*\%(module\|def\|class\|if\|unless\|for\|while\|until\|case\)\>\%(.*[^.:@$]\<end\>\)\@!.*\%#',
          \ '^\s*\%(begin\)\s*\%#',
          \ '\%(^\s*#.*\)\@<!do\%(\s*|\k\+\%(\s*,\s*\k\+\)*|\)\?\s*\%#',
          \ ]
      call smartinput#define_rule({
            \ 'at': ptn,
            \ 'char': '<CR>',
            \ 'input': cr.'end<Esc>O',
            \ 'filetype': ['ruby'],
            \ })
    endfor

    call smartinput#define_rule({
          \ 'at': '\<\%(if\|unless\)\>.*\%#',
          \ 'char': '<CR>',
          \ 'input': cr.'end<Esc>O',
          \ 'filetype': ['ruby'],
          \ 'syntax': ['rubyConditionalExpression']
          \ })

    " vim
    for word in ['function', 'if', 'for', 'while', 'try']
      call smartinput#define_rule({
            \ 'at': '^\s*'.word.'\>.*\%#',
            \ 'char': '<CR>',
            \ 'input': cr.'end'.word.'<Esc>O',
            \ 'filetype': ['vim'],
            \ })
    endfor

    " sh
    for pair in [
          \ [ '^\s*if\>.*\%#', 'fi' ],
          \ [ '^\s*case\>.*\%#', 'esac'],
          \ [ '\%(^\s*#.*\)\@<!do\>.*\%#', 'done' ],
          \ ]
      call smartinput#define_rule({
            \ 'at': pair[0],
            \ 'char': '<CR>',
            \ 'input': cr.pair[1].'<Esc>O',
            \ 'filetype': ['sh', 'zsh'],
            \ })
    endfor
  endfunction

  call s:plug.register_hook('vim-smartinput')
endif


" tcomment.vim {{{1
"
if s:plug.is_installed('tcomment_vim')
  " <LEADER>cでコメントのトグル
  " 一行コメントは<LEADER>cでトグル
  let g:tcommentMapLeaderOp1 = '<LEADER>c'
  let g:tcommentMapLeaderOp2 = '<LEADER>C'
endif


" vim-quickhl {{{1
"
if s:plug.is_installed('vim-quickhl')
  " カーソル下の単語、または選択範囲をハイライト
  nmap <LEADER>m <Plug>(quickhl-manual-this)
  xmap <LEADER>m <Plug>(quickhl-manual-this)
  " すべてのハイライトをクリア
  nmap <LEADER>M <Plug>(quickhl-manual-reset)
  xmap <LEADER>M <Plug>(quickhl-manual-reset)
endif


" indent-guides {{{1
"
if s:plug.is_installed('vim-indent-guides')
  " 有効/無効トグル
  noremap <silent>[toggle]i :<C-u>IndentGuidesToggle<CR>

  function! s:plug_vim_indent_guides()
    " デフォルトは無効にしておく <LEADER><LEADER>iで有効化
    let g:indent_guides_enable_on_vim_startup = 0
    " ガイドを見やすく
    let g:indent_guides_color_change_percent = 5
    let g:indent_guides_guide_size = 1
  endfunction

  call s:plug.register_hook('vim-indent-guides')
endif


" ShowMarks7 {{{1
"
if s:plug.is_installed('ShowMarks7')
  let showmarks_enable = 1
  " Show which marks
  let showmarks_include = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
  " help、quickfixと編集不可のバッファのマークを表示しない
  let showmarks_ignore_type = 'hqm'
  " Hilight lower & upper marks
  " let showmarks_hlline_lower = 1
  " let showmarks_hlline_upper = 1

  " color setting
  function! s:chg_showmarks_color()
    hi! link SignColumn LineNr
    hi! link ShowMarksHLl LineNr
    hi! link ShowMarksHLu LineNr
    hi! link ShowMarksHLo LineNr
    hi! link ShowMarksHLm LineNr
  endfunction

  augroup _chg_showmarks_colors
    au! ColorScheme * call s:chg_showmarks_color()
  augroup END

  " change keymap
  map mt <Plug>ShowmarksShowMarksToggle
  map mo <Plug>ShowmarksShowMarksOn
  map mm <Plug>ShowmarksPlaceMark
  map mc <Plug>ShowmarksClearMark
  map mM <Plug>ShowmarksClearAll
  nnoremap <silent><Plug>ShowmarksShowMarksToggle :<C-u>ShowMarksToggle<CR>
  nnoremap <silent><Plug>ShowmarksShowMarksOn :<C-u>ShowMarksOn<CR>
  nnoremap <silent><Plug>ShowmarksPlaceMark :<C-u>ShowMarksPlaceMark<CR>
  nnoremap <silent><Plug>ShowmarksClearMark :<C-u>ShowMarksClearMark<CR>
  nnoremap <silent><Plug>ShowmarksClearAll :<C-u>ShowMarksClearAll<CR>
endif


" vim-over {{{1
"
if s:plug.is_installed('vim-over')
  nnoremap <silent><LEADER>: :OverCommandLine<CR>
  " カーソル下の単語をハイライト付きで置換
  " nnoremap sub :OverCommandLine<CR>%s/<C-r><C-w>//g<Left><Left>
  " コピーした文字列をハイライト付きで置換
  " nnoremap subp y:OverCommandLine<CR>%s!<C-r>=substitute(@0, '!', '\\!', 'g')<CR>!!gI<Left><Left><Left>
endif


" taglist.vim {{{1
"
if s:plug.is_installed('taglist.vim')
  " taglist開閉トグル
  nnoremap <silent>[toggle]t :TlistToggle<CR>

  function! s:plug_taglist_vim()
    " 現在表示中のファイルのみのタグしか表示しない
    let g:Tlist_Show_One_File = 1
    " taglisの幅
    let g:Tlist_WinWidth = 40
    " 右側にtaglistを表示
    let g:Tlist_Use_Right_Window = 1
    " taglistのウインドウだけならvimを閉じる
    let g:Tlist_Exit_OnlyWindow = 1
  endfunction

  call s:plug.register_hook('taglist.vim')
endif


" alpaca_tags {{{1
"
if s:plug.is_installed('alpaca_tags')
  function! s:plug_alpaca_tags()
    " ctags option
    let g:alpaca_tags#config = {
          \   '_' : '-R --sort=yes',
          \   'js' : '--languages=+js',
          \   '-js' : '--languages=-js,JavaScript',
          \   'vim' : '--languages=+Vim,vim',
          \   'php' : '--languages=+php',
          \   '-vim' : '--languages=-Vim,vim',
          \   '-style': '--languages=-css,scss,js,JavaScript,html',
          \   'scss' : '--languages=+scss --languages=-css',
          \   'css' : '--languages=+css',
          \   'java' : '--languages=+java $JAVA_HOME/src',
          \   'ruby': '--languages=+Ruby',
          \   'coffee': '--languages=+coffee',
          \   '-coffee': '--languages=-coffee',
          \   'bundle': '--languages=+Ruby',
          \ }

    " Specify directories to store generated tags.
    let g:alpaca_tags#cache_dir = $VIMLOCAL.'/tmp/cache/alpaca_tags'
    " If it is as following, debug is shown.
    " let g:alpaca_tags#console = { 'report' : 1 }

    augroup _alpaca_aucmd
      au!
      au BufWritePost Gemfile AlpacaTagsBundle
      au BufEnter * AlpacaTagsSet
      au BufWritePost * AlpacaTagsUpdate
    augroup END
  endfunction

  call s:plug.register_hook('alpaca_tags')
endif


" a.vim {{{1
"
if s:plug.is_installed('a.vim')
  function! s:plug_a_vim()
    nnoremap [avim] <Nop>
    nmap     <LEADER>a [avim]

    " C/C++のヘッダーとソースを切り替える
    nnoremap <silent>[avim]a :<C-u>A<CR>
    " 縦分割で開く
    nnoremap <silent>[avim]v :<C-u>AV<CR>
    " 横分割で開く
    nnoremap <silent>[avim]s :<C-u>AS<CR>
    " 新規タブで開く
    nnoremap <silent>[avim]t :<C-u>AT<CR>
    " 以下はマッピング済み
    " <Leader>ih  カーソル下のファイルを開く
    " <Leader>is  カーソル下のファイルに対応するヘッダー/ソースを分割して開く
    " <Leader>ihn 循環マッチ?
  endfunction

  call s:plug.register_hook('a.vim')
endif


" neocomplete.vim {{{1
"
if s:plug.is_installed('neocomplete.vim')
  " 自動的に起動 (default 0)
  let g:neocomplete#enable_at_startup = 1

  function! s:plug_neocomplete_vim()
    " AutoComplPopのように最初の候補を選択する (default 0)
    let g:neocomplete#enable_auto_select = 0
    " neocomplcacheのsmart case機能を有効化 (default infercase)
    let g:neocomplete#enable_smart_case = 1
    " 自動補完開始までの待ち時間 (default 2)
    " g:neocomplete#skip_auto_completion_time = 2

    " 補完候補最大表示件数 (default 100)
    let g:neocomplete#max_list = 100

    " シンタックスをキャッシュするときの最小文字長 (default 4)
    let g:neocomplete#sources#syntax#min_keyword_length = 3
    " neocomplcacheを自動的にロックするバッファ名のパターンを指定
    let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'

    " 辞書ディレクトリ
    " let g:neocomplete#sources#dictionary#dictionaries = {
    "     \ 'default': '',
    "     \ 'vimshell': $HOME.'/.vimshell_hist',
    "     \ 'scheme': $HOME.'/.gosh_completions'
    "         \ }

    " cache directory
    let g:neocomplete#data_directory = $VIMLOCAL.'/tmp/cache/neocomplete'

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " オムニ補完キーワード
    if !exists('g:neocomplete#sources#omni#input_patterns')
      let g:neocomplete#sources#omni#input_patterns = {}
    endif
    let g:neocomplete#sources#omni#input_patterns.c =
          \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
    let g:neocomplete#sources#omni#input_patterns.cpp =
          \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
    let g:neocomplete#sources#omni#input_patterns.ruby =
          \ '[^. *\t]\.\w*\|\h\w*::'
    let g:neocomplete#sources#omni#input_patterns.php =
          \ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
    let g:neocomplete#sources#omni#input_patterns.perl =
          \ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

    " キーワード補完
    inoremap <expr><C-n> pumvisible() ? "\<C-n>" : neocomplete#start_manual_complete()
    inoremap <expr><C-p> pumvisible() ? "\<C-n>" : neocomplete#start_manual_complete()

    " 前回の保管候補をキャンセル
    inoremap <expr><C-g> neocomplete#undo_completion()
    " 補完候補のなかから、共通する部分を補完
    inoremap <expr><C-l> neocomplete#complete_common_string()

    " Enterでポップアップを閉じて改行
    " inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    " function! s:my_cr_function()
    "   return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
    "   " For no inserting <CR> key.
    "   "return pumvisible() ? "\<C-y>" : "\<CR>"
    " endfunction

    " TABキーでキーワード補完
    inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"

    " neocompleteの補完を選択し、ポップアップメニューを閉じる
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"

    " 有効/無効のトグル
    nnoremap <silent>[toggle]x :NeoCompleteToggle<CR>
  endfunction

  call s:plug.register_hook('neocomplete.vim')
endif


" vim-marching {{{1
"
if s:plug.is_installed('vim-marching')
  function! s:plug_vim_marching()
    if executable(g:marching_clang_command)
      let g:marching_backend =
            \ s:plug.is_installed('vimproc.vim') ?
            \     'clang_command' : 'sync_clang_command'
      " let g:marching_backend = 'sync_clang_command'
    elseif executable('curl') || executable('wget')
      " clang コマンドが実行できなければ wandbox を使用する
      let g:marching_backend = 'sync_wandbox'
      let g:marching_clang_command = ''
    endif

    " 複数候補があった時に重複して表示しない
    " let g:marching_enable_dup = 0

    " オプションの設定
    " これは clang のコマンドに渡される
    " let g:marching#clang_command#options = {
    "       \	'cpp': '-std=gnu++1y'
    "       \}

    " インクルードディレクトリのパスを設定
    " let g:marching_include_paths = [
    " \   'C:/MinGW/lib/gcc/mingw32/4.6.2/include/c++'
    " \   'C:/cpp/boost'
    " \]

    " neocompleteとの連携
    if s:plug.is_installed('neocomplete.vim')
      let g:marching_enable_neocomplete = 1
      if !exists('g:neocomplete#force_omni_input_patterns')
        let g:neocomplete#force_omni_input_patterns = {}
      endif
      let g:neocomplete#force_omni_input_patterns.cpp =
            \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
    endif

    " vimprocの更新間隔を短くして候補表示を早くする
    if s:plug.is_installed('vimproc.vim')
      setlocal updatetime=1000
    endif

    " オムニ補完時に補完ワードを挿入したくない場合
    imap <buffer> <C-x><C-o> <Plug>(marching_start_omni_complete)
    " キャッシュを削除してからオムに補完を行う
    imap <buffer> <C-x><C-x><C-o> <Plug>(marching_force_start_omni_complete)
  endfunction

  call s:plug.register_hook('vim-marching')
endif


" javacomplete {{{1
"
if s:plug.is_installed('javacomplete')
  function! s:plug_javacomplete()
    augroup _java_completefunc
      au! FileType java setlocal omnifunc=javacomplete#Complete
                              \ completefunc=javacomplete#CompleteParamsInfo
    augroup END
  endfunction

  call s:plug.register_hook('javacomplete')
endif


" rsense {{{1
"
if s:plug.is_installed('rsense')
  " rsense実行可否チェック
  function! s:executable_rsense()
    return executable('ruby') && g:is_win ?
          \ g:myfuncs.chomp(system('sc query rsense | find "SERVICE_NAME"')) != '' : 1
  endfunction

  function! s:plug_rsense()
    let g:rsenseUseOmniFunc = 1

    if s:plug.is_installed('neocomplete.vim')
      if !exists('g:neocomplete#force_omni_input_patterns')
        let g:neocomplete#force_omni_input_patterns = {}
      endif
      let g:neocomplete#force_omni_input_patterns.ruby =
            \ '[^. *\t]\.\w*\|\h\w*::'
    endif

    " 確実に有効化するための措置
    call SetupRSense()
  endfunction

  augroup _plug_rsense
    au!
    au FileType ruby if <SID>executable_rsense() | call plug#load('rsense') | endif
    au User rsense call s:plug_rsense() | au! _plug_rsense
  augroup END
endif


" neosnippet.vim {{{1
"
if s:plug.is_installed('neosnippet.vim')
  function! s:plug_neosnippet_vim()
    " cache directory
    let g:neosnippet#data_directory = $VIMLOCAL.'/tmp/cache/neosnippet'
    " For snippet_complete marker.
    if has('conceal')
      set conceallevel=2 concealcursor=i
    endif

    " Enable snipMate compatibility feature.
    let g:neosnippet#enable_snipmate_compatibility = 1

    " disable runtime snippets
    let g:neosnippet#disable_runtime_snippets = { '_': 1, }

    " initialize snippets directory
    let g:neosnippet#snippets_directory = []

    " load my snippets
    let mysnip = $VIMLOCAL.'/snippets'
    if isdirectory(mysnip)
      let g:neosnippet#snippets_directory += [ mysnip ]
    endif

    " load Shougo/neosnippet-snippets
    if s:plug.is_installed('neosnippet-snippets')
      let g:neosnippet#snippets_directory += [ $VIMLOCAL.'/bundle/neosnippet-snippets/neosnippets' ]
    endif

    " load honza/vim-snippets
    if s:plug.is_installed('vim-snippets')
      let g:neosnippet#snippets_directory += [ $VIMLOCAL.'/bundle/vim-snippets/snippets' ]
    endif

    " Plugin key-mappings.
    imap <C-k> <Plug>(neosnippet_expand_or_jump)
    smap <C-k> <Plug>(neosnippet_expand_or_jump)
    xmap <C-k> <Plug>(neosnippet_expand_target)

    " SuperTab like snippets behavior.
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
          \ "\<Plug>(neosnippet_expand_or_jump)"
          \: pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
          \ "\<Plug>(neosnippet_expand_or_jump)"
          \: "\<TAB>"
  endfunction

  call s:plug.register_hook('neosnippet.vim')
endif


" unite.vim {{{1
"
if s:plug.is_installed('unite.vim')
  " キーマップ定義
  nnoremap [unite] <Nop>
  nmap     <LEADER>u [unite]
  " 常用セット
  nnoremap <silent>[unite]u  :<C-u>Unite -buffer-name=files buffer file file_mru bookmark<CR>
  " レジューム
  nnoremap <silent>[unite]U  :<C-u>UniteResume<CR>
  " バッファ一覧
  nnoremap <silent>[unite]b  :<C-u>Unite buffer<CR>
  " バッファ一覧(カレントタブ)
  nnoremap <silent>[unite]B  :<C-u>Unite buffer_tab<CR>
  " ファイル一覧
  nnoremap <silent>[unite]f  :<C-u>Unite -buffer-name=files file<CR>
  " ファイル一覧(現在開いているファイルのディレクトリ)
  nnoremap <silent>[unite]F  :<C-u>UniteWithBufferDir -buffer-name=files file<CR>
  " ファイル一覧(再帰)
  nnoremap <silent>[unite]r  :<C-u>Unite -buffer-name=files file_rec<CR>
  " ファイル一覧(再帰 現在開いているファイルのディレクトリ)
  nnoremap <silent>[unite]R  :<C-u>UniteWithBufferDir -buffer-name=files file_rec<CR>
  " nnoremap <silent>[unite]FR :<C-u>Unite -buffer-name=files file_rec:<C-r>=expand('%:p:h:gs?[ :]?\\\0?')<CR><CR>
  " ディレクトリ一覧
  nnoremap <silent>[unite]d  :<C-u>Unite -buffer-name=files directory<CR>
  " ディレクトリ一覧(現在開いているファイルのディレクトリ)
  nnoremap <silent>[unite]D  :<C-u>UniteWithBufferDir -buffer-name=files directory<CR>
  " 最近使用したファイル一覧
  nnoremap <silent>[unite]mf :<C-u>Unite -buffer-name=files file_mru<CR>
  " 最近使用したディレクトリ一覧
  nnoremap <silent>[unite]md :<C-u>Unite -buffer-name=files directory_mru<CR>
  " ブックマーク一覧
  nnoremap <silent>[unite]M  :<C-u>Unite -buffer-name=files bookmark<CR>
  " ヤンク履歴
  nnoremap <silent>[unite]y  :<C-u>Unite -buffer-name=register history/yank<CR>
  " コマンド一覧
  nnoremap <silent>[unite]c  :<C-u>Unite command<CR>
  " 以下、追加source
  " ヘルプ (unite-help)
  nnoremap <silent>[unite]h  :<C-u>Unite help<CR>
  " アウトライン (unite-outline)
  nnoremap <silent>[unite]o :<C-u>Unite outline<CR>
  " マーク一覧 (unite-mark)
  nnoremap <silent>[unite]m :<C-u>Unite mark<CR>

  " outlineトグル
  nnoremap <silent>[toggle]o :<C-u>Unite -vertical -no-quit -toggle -no-focus -no-start-insert -winwidth=40 outline<CR>
  nnoremap <silent>[toggle]O :<C-u>Unite -vertical -direction=belowright -no-quit -toggle -no-focus -no-start-insert -winwidth=40 outline<CR>

  " vim-ref
  if s:plug.is_installed('vim-ref')
    augroup _unite_ref_keymap
      au! FileType sh nnoremap <silent>[unite]r  :<C-u>Unite ref/man<CR>
      au! FileType ruby nnoremap <silent>[unite]r  :<C-u>Unite ref/refe<CR>
      au! FileType perl nnoremap <silent>[unite]r  :<C-u>Unite ref/perldoc<CR>
      au! FileType python nnoremap <silent>[unite]r  :<C-u>Unite ref/pydoc<CR>
    augroup END
  endif

  " キーマップ一覧
  command! -nargs=0 UniteKeyMap Unite output:map|map!|lmap
  " カラースキーマー検索 自動プレビュー付き
  command! -nargs=0 UniteColorSchemePreview Unite colorscheme -auto-preview

  function! s:plug_unite_vim()
    " load unite-sources
    call plug#load(
          \ 'unite-outline',
          \ 'unite-help',
          \ 'unite-tag',
          \ 'unite-mark',
          \ 'unite-scriptnames',
          \ 'unite-colorscheme',
          \ 'neoyank.vim',
          \ )

    " 入力モードで開始する
    let g:unite_enable_start_insert = 1
    " Uniteを縦分割で開始する
    "let g:unite_enable_split_vertically
    " history/yankの有効化
    let g:unite_source_history_yank_enable = 1
    " ステータスラインを書き換えない
    let g:unite_force_overwrite_statusline = 0
    " cache directory
    let g:unite_data_directory = $VIMLOCAL.'/tmp/cache/unite'

    " default actionの変更
    call unite#custom_default_action('source/bookmark/directory', 'vimfiler')
    call unite#custom_default_action('vimshell/history', 'insert')
    " call unite#custom_default_action('guicmd', 'start')

    " unite-grepに関する設定
    if g:is_win
      let g:unite_source_grep_command = "grep"
      let g:unite_source_grep_recursive_opt = "-r"
      let g:unite_source_grep_default_opts = "-Hn"
    endif

    " no-quit付きで開かれているバッファは閉じないquit
    function! s:unite_smart_quit()
        if (exists("b:unite.context.no_quit") && b:unite.context.no_quit)
          " do nothing
        else
          exe "normal \<Plug>(unite_exit)"
        endif
    endfunction

    function! s:chg_unite_keymap()
      " 普通に開く
      nnoremap <silent><buffer><expr>o unite#do_action('open')
      inoremap <silent><buffer><expr>o unite#smart_map("o", unite#do_action('open'))
      " 横に分割して開く
      nnoremap <silent><buffer><expr>s unite#do_action('split')
      inoremap <silent><buffer><expr>s unite#smart_map("s", unite#do_action('split'))
      " 縦に分割して開く
      nnoremap <silent><buffer><expr>v unite#do_action('vsplit')
      inoremap <silent><buffer><expr>v unite#smart_map("v", unite#do_action('vsplit'))
      " タブで開く
      nnoremap <silent><buffer><expr>t unite#do_action('tabopen')
      inoremap <silent><buffer><expr>t unite#smart_map("t", unite#do_action('tabopen'))

      " 再描画と再キャッシュ
      nmap <buffer><C-r> <Plug>(unite_redraw)

      " Ctrl+h,j,k,lで分割ウィンドウ移動
      noremap <silent><buffer><C-h> <C-w>h
      noremap <silent><buffer><C-j> <C-w>j
      noremap <silent><buffer><C-k> <C-w>k
      noremap <silent><buffer><C-l> <C-w>l

      " ESCキーを2回押すと終了する
      nnoremap <silent><buffer><ESC><ESC> :<C-u>:call <SID>unite_smart_quit()<CR>
      inoremap <silent><buffer><ESC><ESC> <ESC>:<C-u>:call <SID>unite_smart_quit()<CR>
    endfunction

    augroup _unite_chg_keymap
      au! FileType unite call s:chg_unite_keymap()
    augroup END
  endfunction

  call s:plug.register_hook('unite.vim')
endif


" neomru {{{1
if s:plug.is_installed('neomru.vim')
  " cache directory
  let g:neomru#file_mru_path = $VIMLOCAL.'/tmp/cache/neomru/file'
  let g:neomru#directory_mru_path = $VIMLOCAL.'/tmp/cache/neomru/directory'
endif


" vimfiler.vim {{{1
"
if s:plug.is_installed('vimfiler.vim')
  nnoremap [vimfiler] <Nop>
  nmap     <LEADER>vf [vimfiler]
  nnoremap [vimfiler] :<C-u>VimFiler<CR>

  function! s:plug_vimfiler_vim()
    " load unite.vim
    call plug#load('unite.vim')

    let g:vimfiler_as_default_explorer = 1
    " Enable file operation commands.
    let g:vimfiler_safe_mode_by_default = 0
    " Use trashbox.
    let g:unite_kind_file_use_trashbox = 1
    " ステータスラインを書き換えない
    let g:vimfiler_force_overwrite_statusline = 0
    " cache directory
    let g:vimfiler_data_directory = $VIMLOCAL.'/tmp/cache/vimfiler'

    " 関連付け
    call vimfiler#set_execute_file('vim', 'vim')
    call vimfiler#set_execute_file('txt', 'vim')

    " 自動的にカーソルラインをオン
    augroup _vimfiler_curline_on
      au!
      au FileType vimfiler setlocal cursorline
      au FileType vimfiler hi CursorLine gui=underline
    augroup END

    function! s:chg_vimfiler_keymap()
      " Enterでディレクトリはツリー展開、ファイルは開く
      nmap <silent><buffer><expr><CR> vimfiler#smart_cursor_map(
            \ "\<Plug>(vimfiler_expand_tree)", "\<Plug>(vimfiler_edit_file)")
      " 普通に開く
      nmap <silent><buffer><expr>o vimfiler#smart_cursor_map(
            \ "\<Plug>(vimfiler_expand_tree)", vimfiler#do_action('open'))
      " 横に分割して開く
      nmap <silent><buffer><expr>s vimfiler#smart_cursor_map(
            \ "\<Plug>(vimfiler_expand_tree)", vimfiler#do_action('split'))
      " 縦に分割して開く
      nmap <silent><buffer><expr>v vimfiler#smart_cursor_map(
            \ "\<Plug>(vimfiler_expand_tree)", vimfiler#do_action('vsplit'))
      " タブで開く
      nnoremap <silent><buffer><expr>t vimfiler#do_action('tabopen')
      " Unite bookmarkを開く
      nnoremap <buffer>b :<C-u>Unite -buffer-name=files bookmark<CR>
      " map <buffer> a <Plug>(vimfiler_toggle_mark_all_lines)
      " map <End> <Plug>(vimfiler_clear_mark_all_lines)
      " map <buffer> @ <Plug>(vimfiler_set_current_mask)
    endfunction

    augroup _vimfiler_chg_keymap
      au! FileType vimfiler call s:chg_vimfiler_keymap()
    augroup END
  endfunction

  call s:plug.register_hook('vimfiler.vim')
endif


" vimshell.vim {{{1
"
if s:plug.is_installed('vimshell.vim')
  nnoremap [vimshell] <Nop>
  nmap     <LEADER>vs [vimshell]
  nnoremap [vimshell] :<C-u>VimShell<CR>

  function! s:plug_vimshell_vim()
    " ステータスラインを書き換えない
    let g:vimshell_force_overwrite_statusline = 0
    " cache directory
    let g:vimshell_data_directory = $VIMLOCAL.'/tmp/cache/vimshell'
  endfunction

  call s:plug.register_hook('vimshell.vim')
endif


" NERDTree {{{1
"
if s:plug.is_installed('nerdtree')
  " NERDTree開閉トグル
  nnoremap <silent>[toggle]n :NERDTreeToggle<CR>
  nnoremap <silent><LEADER><Tab> :<C-u>call <SID>jump_nerdtree()<CR>

  " 無かったら開く、あったらフォーカス
  function! s:jump_nerdtree()
    let num = g:myfuncs.find_window_if("&filetype == 'nerdtree'")
    if num
      exe num.'wincmd w'
    else
      exe 'NERDTreeToggle'
    endif
  endfunction

  function! s:plug_nerdtree()
    " NERDTreeの幅
    " let g:NERDTreeWinSize=40
    " 左側にNERDTreeを表示
    let g:NERDTreeWinPos = "left"
    " 隠しファイルを表示する
    let g:NERDTreeShowHidden = 1
    " NERDTreeのウインドウだけならvimを閉じる
    augroup _close_nerdtree_only
      au!
      au bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType")
            \ && b:NERDTreeType == "primary") | q | endif
    augroup END
  endfunction

  call s:plug.register_hook('nerdtree')
endif


" quickrun.vim {{{1
"
if s:plug.is_installed('vim-quickrun')
  nmap <LEADER>r <Plug>(quickrun)

  function! s:plug_vim_quickrun()
    let g:quickrun_config = {}

    " default
    let g:quickrun_config['_'] = {
          \   'runner' : 'vimproc',
          \   'runner/vimproc/updatetime' : 80,
          \   'outputter' : 'error',
          \   'outputter/error/success' : 'buffer',
          \   'outputter/error/error' : 'quickfix',
          \   'outputter/buffer/split' : ':rightbelow 8sp',
          \ }

    " debug
    " let g:quickrun_config['_'] = {
    "       \   'split': '',
    "       \ }

    " c++
    let g:quickrun_config['cpp'] = {
          \   'type':
          \     g:is_win && executable('cl') ? 'cpp/vc' :
          \     executable('clang++') ? 'cpp/clang++' :
          \     executable('g++') ? 'cpp/g++' : '',
          \ }

    let g:quickrun_config['cpp/clang++'] = {
          \   'cmdopt': '-std=c++1y -Wall',
          \ }

    let g:quickrun_config['cpp/g++'] = {
          \   'cmdopt': '-std=c++0x -Wall',
          \ }

    let g:quickrun_config['cpp/vc'] = {
          \   'cmdopt': '/nologo /EHsc',
          \   'hook/output_encode/encoding': '&termencoding',
          \   'exec': ['%c %o %s /Fo%s:p:r.obj /Fe%s:p:r.exe',
          \            '%s:p:r.exe %a'],
          \ }

    " ruby
    let g:quickrun_config['ruby'] = {
          \   'cmdopt': '-w',
          \ }

    " vbs
    let g:quickrun_config['vb'] = {
          \   'command': 'cscript.exe',
          \   'exec': '%C "%S"',
          \ }

    " dosbat
    let g:quickrun_config['dosbatch'] = {
          \   'exec': '%s %a',
          \ }

    " SQL
    let g:quickrun_config['sql'] = {
          \   'type':
          \     g:is_win && executable('sqlcmd') ? 'sql/sqlserver' : '',
          \ }

    " SQLServer
    let g:quickrun_config['sql/sqlserver'] = {
          \   'command': 'sqlcmd',
          \   'cmdopt': '-S "localhost\SQLEXPRESS" -W',
          \   'exec': '%C %o -i "%S"',
          \   'runner': 'system',
          \   'hook/output_encode/encoding': 'sjis',
          \ }

    " xml
    let g:quickrun_config['xml'] = {
          \   'type': 'open_browser',
          \ }

    " html
    let g:quickrun_config['html'] = {
          \   'type': 'open_browser',
          \ }

    " open by browser
    let g:quickrun_config['open_browser'] = {
          \   'exec': '"%S"',
          \   'runner': 'system',
          \   'outputter': 'browser',
          \ }

    " markdown
    let g:quickrun_config['markdown'] = {
          \   'type': 'previm',
          \ }

    " open by previm
    let g:quickrun_config['previm'] = {
          \   'exec': 'PrevimOpen',
          \   'runner': 'vimscript',
          \   'outputter': 'null',
          \ }

    " <C-c> で実行を強制終了させる
    " quickrun.vim が実行していない場合には <C-c> を呼び出す
    nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
  endfunction

  call s:plug.register_hook('vim-quickrun')
endif


" vim-watchdogs {{{1
"
if s:plug.is_installed('vim-watchdogs')
  noremap <silent><LEADER>w :<C-u>WatchdogsRun<CR>

  function! s:plug_vim_watchdogs()
    " load depend plugins
    call plug#load('vim-quickrun', 'shabadou.vim')

    " ファイル書き込み時の自動シンタックスチェックをしない
    let g:watchdogs_check_BufWritePost_enable = 0
    " :wq時にシンタックスチェックしない
    let g:watchdogs_check_BufWritePost_enable_on_wq = 0

    " c++
    let g:quickrun_config["cpp/watchdogs_checker"] = {
          \   'type':
          \     g:is_win && executable('cl') ? 'watchdogs_checker/msvc' :
          \     executable('clang++') ? 'watchdogs_checker/clang++' :
          \     executable('g++') ? 'watchdogs_checker/g++' : '',
          \ }

    let g:quickrun_config['cpp/watchdogs_checker/clang++'] = {
          \   'cmdopt': '-Wall',
          \ }

    let g:quickrun_config['cpp/watchdogs_checker/g++'] = {
          \   'cmdopt': '-Wall',
          \ }

    let g:quickrun_config['watchdogs_checker/msvc'] = {
          \   'cmdopt': '/nologo /EHsc',
          \   'hook/output_encode/encoding': '&termencoding',
          \ }
    " cs
    let g:quickrun_config['cs/watchdogs_checker'] = {
          \   'type':
          \     g:is_win && executable('csc') ? 'watchdogs_checker/csc' :
          \     executable('mcs') ? 'watchdogs_checker/mcs' : '',
          \ }

    let g:quickrun_config['watchdogs_checker/csc'] = {
          \   'command' : 'csc',
          \   'cmdopt' : '/nologo',
          \   'exec': '%c %o %s:p:gs?/?\\?',
          \   'hook/output_encode/encoding': '&termencoding',
          \   'quickfix/errorformat' : '%f\\(%l\\,%c\\):\ error\ CS%n:\ %m',
          \ }

    let g:quickrun_config['watchdogs_checker/mcs'] = {
          \   'command' : 'mcs',
          \   'cmdopt' : '--parse',
          \   'exec' : '%c %o %s:p',
          \   'quickfix/errorformat' : '%f\\(%l\\,%c\\):\ error\ CS%n:\ %m',
          \ }

    " java
    let g:quickrun_config['watchdogs_checker/javac'] = {
          \   'command' : 'javac',
          \   'exec' : '%c %o -d %s:p:h %s:p',
          \   'hook/output_encode/encoding': '&termencoding',
          \   'hook/sweep/files': '%s:p:r.class',
          \   'errorformat': '%A%f:%l: %m,%-Z%p^,%+C%.%#,%-G%.%#',
          \ }

    " ruby
    let g:quickrun_config['cpp/watchdogs_checker/ruby'] = {
          \   'cmdopt': '-w',
          \ }

    call watchdogs#setup(g:quickrun_config)
  endfunction

  call s:plug.register_hook('vim-watchdogs')
endif


" vim-ref {{{1
"
if s:plug.is_installed('vim-ref')
  nmap K <Plug>(ref-keyword)

  function! s:plug_vim_ref()
    " キャッシュディレクトリ
    let g:ref_cache_dir = $VIMLOCAL.'/tmp/cache/vim_ref_cache'
    let g:ref_refe_encoding = 'utf-8'
  endfunction

  call s:plug.register_hook('vim-ref')
endif


" open-browser.vim {{{1
"
if s:plug.is_installed('open-browser.vim')
  " カーソル下のURLをブラウザで開く
  nmap <LEADER>ob <Plug>(openbrowser-open)
  vmap <LEADER>ob <Plug>(openbrowser-open)
  " ググる
  nmap <LEADER>os <Plug>(openbrowser-smart-search)
  vmap <LEADER>os <Plug>(openbrowser-smart-search)
endif


" previm {{{1
"
if s:plug.is_installed('previm')
  function! s:plug_previm()
    call plug#load('open-browser.vim')
  endfunction

  call s:plug.register_hook('previm')
endif


" excitetranslate-vim {{{1
"
if s:plug.is_installed('excitetranslate-vim')
  function! s:plug_excitetranslate_vim()
    call plug#load('webapi-vim')
  endfunction

  call s:plug.register_hook('excitetranslate-vim')
endif


" restart.vim {{{1
"
if s:plug.is_installed('restart.vim')
  function! s:plug_restart_vim()
    " 終了時に保持するオプション
    let g:restart_sessionoptions
          \ = 'blank,buffers,curdir,folds,help,localoptions,tabpages'
  endfunction

  call s:plug.register_hook('restart.vim')
endif


" lightline.vim {{{1
"
if s:plug.is_installed('lightline.vim')
  let g:lightline = {
        \ 'colorscheme': 'jellybeans',
        \ 'active': {
        \   'left':  [ [ 'mode', 'paste' ],
        \              [ 'readonly', 'filename', 'modified' ] ],
        \   'right': [ [ 'lineinfo' ],
        \              [ 'percent' ],
        \              [ 'filetype', 'fileencoding', 'fileformat' ] ],
        \ },
        \ 'inactive': {
        \   'left':  [ [ 'readonly', 'filename', 'modified' ] ],
        \   'right': [ [ 'lineinfo' ],
        \              [ 'percent' ],
        \              [ 'filetype', 'fileencoding', 'fileformat' ] ],
        \ },
        \ 'component_function': {
        \   'mode':         'MyMode',
        \   'readonly':     'MyReadonly',
        \   'filename':     'MyFilename',
        \   'modified':     'MyModified',
        \   'filetype':     'MyFiletype',
        \   'fileencoding': 'MyFileencoding',
        \   'fileformat':   'MyFileformat',
        \ }
        \ }

  function! s:special_filetype()
    return index([
          \   'help',
          \   'qf',
          \   'unite',
          \   'vimfiler',
          \   'vimshell',
          \   'quickrun',
          \   'nerdtree',
          \ ], &ft) != -1
  endfunction

  function! MyMode()
    return  <SID>special_filetype() ? &ft :
          \ winwidth('.') < 50 ? '' : lightline#mode()
  endfunction

  function! MyReadonly()
    return  <SID>special_filetype() ? '' :
          \ &readonly ? 'RO' : ''
  endfunction

  function! MyFilename()
    return  &ft == 'unite' ? unite#get_status_string() :
          \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
          \ &ft == 'vimshell' ? vimshell#get_status_string() :
          \ &ft == 'quickrun' ? '' :
          \ &ft == 'nerdtree' ? '' :
          \ strlen(expand('%:t')) ? expand('%:t') : '[No Name]'
  endfunction

  function! MyModified()
    return  <SID>special_filetype() ? '' :
          \ &modified ? '+' : &modifiable ? '' : '-'
  endfunction

  function! MyFiletype()
    return  <SID>special_filetype() || winwidth('.') < 60 ?  '' :
          \ (strlen(&filetype) ? &filetype : 'no ft')
  endfunction

  function! MyFileencoding()
    return  <SID>special_filetype() || winwidth('.') < 60 ?  '' :
          \ (strlen(&fenc) ? &fenc : &enc)
  endfunction

  function! MyFileformat()
    return  <SID>special_filetype() || winwidth('.') < 60 ?  '' :
          \ &fileformat
  endfunction
endif


" vim-loadafterft {{{1
"
if s:plug.is_installed('vim-loadafterft')
  " ftpluginロード後に実行するコマンド
  let g:execcmd_after_ftplugin = {
        \    '_': [
        \        'setlocal fo+=l fo+=m fo+=M fo+=B fo-=r fo-=o fo-=t',
        \    ],
        \ }

  " indentロード後に実行するコマンド
  " let g:execcmd_after_indent = {
  "       \    '_': [
  "       \        'setlocal fo-=t fo-=c fo-=r fo-=o',
  "       \    ],
  "       \    'php': [
  "       \        'setlocal fo-=t fo-=c fo-=r fo-=o',
  "       \    ],
  "       \ }
endif

" {{{1
" vim:set expandtab ft=vim ts=2 sts=2 sw=2 foldmethod=marker:
